
import { afterEach, beforeEach, describe, expect, it } from 'bun:test';
import { resetDB, createDB } from '../helpers';
import { db } from '../db';
import { vulnerabilitiesTable, assetsTable } from '../db/schema';
import { type CreateVulnerabilityInput } from '../schema';
import { createVulnerability } from '../handlers/create_vulnerability';
import { eq } from 'drizzle-orm';

const testInput: CreateVulnerabilityInput = {
  name: 'Test Vulnerability',
  description: 'A vulnerability for testing',
  severity: 'high',
  asset_id: null,
  cve_id: 'CVE-2023-1234',
  discovered_date: new Date('2023-01-15'),
  remediation_plan: 'Apply security patch',
  status: 'open'
};

describe('createVulnerability', () => {
  beforeEach(createDB);
  afterEach(resetDB);

  it('should create a vulnerability', async () => {
    const result = await createVulnerability(testInput);

    // Basic field validation
    expect(result.name).toEqual('Test Vulnerability');
    expect(result.description).toEqual(testInput.description);
    expect(result.severity).toEqual('high');
    expect(result.asset_id).toBeNull();
    expect(result.cve_id).toEqual('CVE-2023-1234');
    expect(result.discovered_date).toEqual(new Date('2023-01-15'));
    expect(result.remediation_plan).toEqual('Apply security patch');
    expect(result.status).toEqual('open');
    expect(result.id).toBeDefined();
    expect(result.created_at).toBeInstanceOf(Date);
    expect(result.updated_at).toBeInstanceOf(Date);
  });

  it('should save vulnerability to database', async () => {
    const result = await createVulnerability(testInput);

    // Query database to verify persistence
    const vulnerabilities = await db.select()
      .from(vulnerabilitiesTable)
      .where(eq(vulnerabilitiesTable.id, result.id))
      .execute();

    expect(vulnerabilities).toHaveLength(1);
    expect(vulnerabilities[0].name).toEqual('Test Vulnerability');
    expect(vulnerabilities[0].severity).toEqual('high');
    expect(vulnerabilities[0].cve_id).toEqual('CVE-2023-1234');
    expect(vulnerabilities[0].status).toEqual('open');
    expect(vulnerabilities[0].created_at).toBeInstanceOf(Date);
  });

  it('should create vulnerability with asset reference', async () => {
    // Create test asset first
    const assetResult = await db.insert(assetsTable)
      .values({
        name: 'Test Server',
        asset_type: 'server',
        owner: 'IT Team'
      })
      .returning()
      .execute();

    const inputWithAsset: CreateVulnerabilityInput = {
      ...testInput,
      asset_id: assetResult[0].id
    };

    const result = await createVulnerability(inputWithAsset);

    expect(result.asset_id).toEqual(assetResult[0].id);

    // Verify in database
    const vulnerabilities = await db.select()
      .from(vulnerabilitiesTable)
      .where(eq(vulnerabilitiesTable.id, result.id))
      .execute();

    expect(vulnerabilities[0].asset_id).toEqual(assetResult[0].id);
  });

  it('should handle vulnerability with all required fields', async () => {
    const minimalInput: CreateVulnerabilityInput = {
      name: 'Critical Bug',
      description: null,
      severity: 'critical',
      asset_id: null,
      cve_id: null,
      discovered_date: new Date('2023-12-01'),
      remediation_plan: null,
      status: 'investigating'
    };

    const result = await createVulnerability(minimalInput);

    expect(result.name).toEqual('Critical Bug');
    expect(result.description).toBeNull();
    expect(result.severity).toEqual('critical');
    expect(result.asset_id).toBeNull();
    expect(result.cve_id).toBeNull();
    expect(result.remediation_plan).toBeNull();
    expect(result.status).toEqual('investigating');
    expect(result.discovered_date).toEqual(new Date('2023-12-01'));
    expect(result.id).toBeDefined();
    expect(result.created_at).toBeInstanceOf(Date);
  });
});
